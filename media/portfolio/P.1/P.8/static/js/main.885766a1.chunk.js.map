{"version":3,"sources":["actions/post.action.js","components/PostForm.js","components/Utils.js","components/User.js","actions/user.action.js","components/Like.js","components/Post.js","App.js","reducers/post.reducer.js","reducers/user.reducer.js","reducers/index.js","index.js"],"names":["GET_POSTS","ADD_POST","EDIT_POST","DELETE_POST","ADD_LIKE","getPosts","dispatch","axios","get","then","res","type","payload","data","catch","err","console","log","addPost","post","PostForm","useState","title","setTitle","content","setContent","useSelector","state","userReducer","useDispatch","handleForm","e","a","preventDefault","author","likes","className","onSubmit","placeholder","value","onChange","target","isEmpty","undefined","Object","keys","length","trim","User","user","pseudo","src","alt","GET_USER","ADD_USER_LIKE","Like","onClick","postData","id","userData","method","url","addUserLike","Post","editToggle","setEditToggle","editContent","setEditContent","handleEdit","postId","default","App","posts","postReducer","map","index","initialState","combineReducers","action","filter","Payload","store","createStore","rootReducer","composeWithDevTools","applyMiddleware","thunk","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.885766a1.chunk.js","sourcesContent":["// Get renvoie de la data, c cette data qu'on veut chercher et mettre dans notre Store ensuite accessible de partout dans notre App\r\n// pr les actions, d'abord créer dossier actions et fichier : post.action.js\r\n// les actions se présentent tjrs comme ça! à faire comme ça!!!\r\n// pr avoir la data dans ordre décroissant ; dans lien ajouter: ?_sort=id&_order=desc\r\nimport axios from \"axios\";\r\n\r\n// pr ajouter des msg's on va parametrer d'abord un addPost : envoyer à la DB\r\n// ensuite (aprés envoie) dispatcher au Reducer les info (attention y a des nouveaux posts)\r\n// on ajoute ADD_POSTS\r\n\r\nexport const GET_POSTS = \"GET_POSTS\";\r\nexport const ADD_POST = \"ADD_POST\";\r\n// pr exploiter la data modifiée dans les actions c EDIT_POST\r\nexport const EDIT_POST = \"EDIT_POST\";\r\n// pr suppression de la data c DELETE_POST\r\nexport const DELETE_POST = \"DELETE_POST\";\r\n// pr ajouter des likes\r\nexport const ADD_LIKE = \"ADD_LIKE\";\r\n\r\n// ICI METHODE GET (CRUD)\r\nexport const getPosts = () => {\r\n  return (dispatch) => {\r\n    return axios\r\n      .get(\"http://localhost:3001/posts?_sort=id&_order=desc\")\r\n      .then((res) => {\r\n        dispatch({ type: GET_POSTS, payload: res.data });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n// il faut récupérer cette data pour type: GET_POSTS ; faut aller dans notre Reducer et lui dire comment traiter ça\r\n\r\n// ICI METHODE POST (CRUD)\r\n// d'abord on copie getPosts (plus haut) et on le change: addPost\r\nexport const addPost = (data) => {\r\n  return (dispatch) => {\r\n    return axios\r\n      .post(\"http://localhost:3001/posts\", data)\r\n      .then((res) => {\r\n        dispatch({ type: ADD_POST, payload: data });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n// on ne peut pas savoir encore si ça marche ; faut aller dans post.reducer et lui expliquer comment traiter cette data du ADD_POST\r\n\r\n// ICI METHODE EDIT (CRUD)\r\n// d'abord on copie addPost (plus haut) et on le change: editPost\r\n// présenter axions pr méthode \"put\" comme suit (c mieux) (il nous faut l'ID de msg en question!!)\r\n// avec les points (...data) c pour envoyer la data en spread operator\r\nexport const editPost = (data) => {\r\n  return (dispatch) => {\r\n    return axios({\r\n      method: \"put\",\r\n      url: `http://localhost:3001/posts/${data.id}`,\r\n      data: { ...data },\r\n    })\r\n      .then((res) => {\r\n        dispatch({ type: EDIT_POST, payload: { ...data } });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n\r\n// ICI METHODE DELETE (CRUD) à faire comme suit: avec postId\r\nexport const deletePost = (postId) => {\r\n  return (dispatch) => {\r\n    return axios({\r\n      method: \"delete\",\r\n      // ATTENTION!!! à faire avec guillements de la touche 7 (pr ci-bàs)\r\n      url: `http://localhost:3001/posts/${postId}`,\r\n    })\r\n      .then((res) => {\r\n        dispatch({ type: DELETE_POST, payload: { postId } });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n// et là nous avons réussie à faire in CRUD (create, read, update, delete)\r\n\r\n// ICI PROCEDURE POUR AJOUTER DES LIKES\r\n// là on fait la logique pr ajout de likes\r\n// on reprend la logique de \"put\"\r\nexport const addLike = (data) => {\r\n  return (dispatch) => {\r\n    return axios({\r\n      method: \"put\",\r\n      url: `http://localhost:3001/posts/${data.id}`,\r\n      data: { ...data },\r\n    })\r\n      .then((res) => {\r\n        dispatch({ type: ADD_LIKE, payload: { ...data } });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n","import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { addPost, getPosts } from \"../actions/post.action\";\n\n// component PostForm pour notre formulaire (haut de page),\n\nconst PostForm = () => {\n  // faut d'abord se récupérer toutes les infos écritent dans ces inputs\n  const [title, setTitle] = useState(\" \");\n  const [content, setContent] = useState(\" \");\n  // on a besoin de l'info du pseudo de l'utilisateur ; avec le HOOK useSelector\n  // useSelector se présent tjrs comme ça!\n  const user = useSelector((state) => state.userReducer);\n  // avec useDispatch ; on dispatch des actions de l'utilisateur (voir fct handleSubmit)\n  const dispatch = useDispatch();\n\n  //pr récupérer valeur input dans React; onChange={e => setTitle(e.target.value)}\n  // événement sur soumission du formulaire: en React c onSubmit\n  // on code la fct handleSubmit:  pour le preventDefault (éviter rechargement de page) ; comme suite\n  // on se fait la var DATA pr stocker dedans la data à envoyer aprés soumission du formulaire\n  const handleForm = async (e) => {\n    e.preventDefault();\n    if (title && content) {\n      const data = {\n        title: title,\n        content: content,\n        // author: user[0].pseudo, // ma DB User n'est pas lu! à vérifier!!\n        author: \"adel\",\n        likes: 0,\n      };\n      // on passe tt ça aux actions ; il nous manque un Dispatch\n      // mainteant on va faire des dispatch aux actions de l'utilisateur (pas seulement quand la page s'ouvre comme avant \"voir index.js\")\n      // on fait comme suite:   dispatch(addPost(data));\n      await dispatch(addPost(data));\n      // pr faire un reset du formulaire aprés chaque soumission du form\n      setTitle(\"\");\n      setContent(\"\");\n      // car l'id est utile pr faire des éditions et des suppréssions!!! c comme ça qu'on va pointer dans ka DB l'article en question\n      // c pr ça qu'il faut quand on crée un nouvel artcicle qu'on demade à la DB (le Back)\n      // on a pas le choix; faut passer par la DB car c la DB qui met l'ID\n      // comme on a à chaque fois un nouvel ID (généré pr chaque nouvel publication); faut faire un appel à la DB comme ça:\n      dispatch(getPosts());\n      // pr être sûre que l'ID à été mis avant de lancer le getPosts; on met la fct en async et on met : await (voir plus haut)\n      // ce qui veut dire tt ce code là ( aprés: dispatch(addPost(data)) ) ; va attendre que la data soit bien ajouté!\n    }\n  };\n\n  return (\n    <div className=\"form-container\">\n      <form onSubmit={(e) => handleForm(e)}>\n        <input\n          type=\"text\"\n          placeholder=\"Titre du poste\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n        />\n        <textarea\n          placeholder=\"Postez vos pensées...\"\n          value={content}\n          onChange={(e) => setContent(e.target.value)}\n        ></textarea>\n        <input type=\"submit\" value=\"Envoyer\" />\n      </form>\n    </div>\n  );\n};\n\nexport default PostForm;\n","// si on a : TypeError: posts.map is not a function...\n// faudrai utiliser useEffect() et attendre que le component est monté ou le store est remplis\n// ou on peut utiliser la fct isEmpty; elle permet de vérifier qu'un élément n'est pas vide\n// on va lui dire: on va tester:  {!isEmpty(posts) && posts.map((post, index)  --voir app.js\n\nexport const isEmpty = (value) => {\n  return (\n    value === undefined ||\n    value === null ||\n    (typeof value === \"object\" && Object.keys(value).length === 0) ||\n    (typeof value === \"string\" && value.trim().length === 0)\n  );\n};\n","import React from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { isEmpty } from \"./Utils\";\n\n//partie User (component) pr inserer une logique d'utilisateur (pseudo, photo, âge, nbr de likes)\n\nconst User = () => {\n  const user = useSelector((state) => state.userReducer);\n\n  return (\n    <div className=\"user-container\">\n      <div className=\"user\">\n        <h3>{!isEmpty(user[0]) && user[0].pseudo}</h3>\n        <img src=\"https://thispersondoesnotexist.com/image\" alt=\"\" />\n        <p>Age : 35 ans</p>\n        <p>\n          Like{!isEmpty(user[0]) && user[0].likes > 1 ? \"s\" : null} :{\" \"}\n          {!isEmpty(user[0]) && user[0].likes}\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default User;\n","// d'abord on prend le contenu de post.action.js, on le copie ici et au lieu de GET_POSTS c : GET_USER\r\n// pour info : on dispatch dans le store!\r\nimport axios from \"axios\";\r\n\r\nexport const GET_USER = \"GET_USER\";\r\nexport const ADD_USER_LIKE = \"ADD_USER_LIKE\";\r\n\r\nexport const getUser = () => {\r\n  return (dispatch) => {\r\n    return axios\r\n      .get(\"http://localhost:3001/users\")\r\n      .then((res) => {\r\n        dispatch({ type: GET_USER, payload: res.data });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n\r\n// ICI PROCEDURE POUR AJOUTER DES LIKES\r\n// là on fait la logique pr ajout de likes\r\n// on reprend la logique de \"put\"\r\nexport const addUserLike = (data) => {\r\n  return (dispatch) => {\r\n    return axios({\r\n      method: \"put\",\r\n      url: `http://localhost:3001/posts/${data.id}`,\r\n      data: { ...data },\r\n    })\r\n      .then((res) => {\r\n        dispatch({ type: ADD_USER_LIKE, payload: { ...data } });\r\n      })\r\n      .catch((err) => console.log(err));\r\n  };\r\n};\r\n","import React from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { addLike } from \"../actions/post.action\";\nimport { addUserLike } from \"../actions/user.action\";\n\n// component Like pour nos like\n// maintenant va gérer le compteur de like! on appuyant sur la petite main; on va déclencher une action\n// action pr incrémenter le compteur de like de l'article et le compteur de like de notre utilisateur\n// pr ajouter des likes ; faut éditer le compteur dans notre DB (pr db posts et db users)\n// faut alors faire 2 dispatch différents; un pour post.reducer et un autre pour user.reducer\n\nconst Like = ({ post }) => {\n  // on va dans le store; et on lui dit: ceci\n  const user = useSelector((state) => state.userReducer);\n  // on définit la fct handleLike et l'objet postData et userData pour comptage des likes\n  // maintenant faut dispatcher ces deux informations!\n  const dispatch = useDispatch();\n\n  const handleLike = () => {\n    const postData = {\n      title: post.title,\n      author: post.author,\n      content: post.content,\n      likes: ++post.likes,\n      // c likes qui doit changer réellement; on redéfinit les autres à cause de json server (sinon il éfface tout)\n      // ++post.likes (avec les + à gauche) signifie qu'il reprend le chiffre et il lui fait +1 (pr pérformance c mieux à gauche )\n      id: post.id,\n    };\n    const userData = {\n      pseudo: user[0].pseudo,\n      likes: ++user[0].likes,\n      id: post.id,\n    };\n    dispatch(addLike(postData));\n    dispatch(addUserLike(userData));\n  };\n  // faut reprendre le return comme ce qui suit!!!\n  return (\n    <div onClick={handleLike}>\n      <img src=\"./icons/clap.png\" className=\"clap\" alt=\"clap\" />\n      <span>{post.likes}</span>\n    </div>\n  );\n};\n\nexport default Like;\n","import React, { useState } from \"react\";\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { deletePost, editPost } from \"../actions/post.action\";\nimport Like from \"./Like\";\nimport { isEmpty } from \"./Utils\";\n\n// component Post pr design des msg, et les msg qu'on va lister dans la page web\n// on a destructuré ici ; au lieu de ({ post }) on peut écrire: (props.post)\n\nconst Post = ({ post }) => {\n  // on vérifie d'abord si l'utiisateur est bien l'auteur de l'article (pr pas qu'il supprime des article qui ne sont pas à lui)\n  // on crée d'abord var user\n  const user = useSelector((state) => state.userReducer);\n  // ensuite on fait comme tel: {!isEmpty(user[0]) && user[0].pseudo .... ect (voir en bàs)}\n  // ici le post.author il est égal au pseudo de notre utilisateur!\n  // on crée un toggle: const editToggle ...\n  const [editToggle, setEditToggle] = useState(false);\n  // il sera sur \"true\" quand on clicke pr éditer notre texte, on met onClick dans l'image du edit\n  // et tu met l'inverse de editToggle; comme suite ( setEditToggle(!editToggle) )\n  // ici prob avec db user; j'enlève {!isEmpty(user[0]) && user[0].pseudo === post.author && ( ) : pr vérifier que c le même utilisateur\n  // {!isEmpty(user[0]) && user[0].pseudo === post.author && (tt mettre à l'intéreur avant le <h2>)}\n  // malheuresement là on peut edite et delete pr tt les articles (même dont les auteurs sont différents) (voir erreur avec db user)\n  // si toggle est sur true alors affiche input à la place de notre paragraphe <p> (voir plus bàs dans  : editToggle ?)\n  // faut remettre le prevent.default() dans le nouveau form (pr éviter rechargement de page)\n  // ici fct handleSubmit pr éviter rechargement de la page aprés soumission du nouveau form avec les modifications (méthode edit)\n  // faire le HOOK editContent pr stocker les modifs aprés éditions, attention!! sa valeur de base : post.content!!!!!!!\n  const [editContent, setEditContent] = useState(post.content);\n  // appel du HOOK useDispatch();\n  const dispatch = useDispatch();\n  // codage de la fct handleEdit (en cas d'édition des msg)\n  // quand on bosse avec une vrai DB (pas Json server) on a besoin de changer que editContent (où il y des modifs) ici on refait tt car il écrasera sinon\n  const handleEdit = (e) => {\n    e.preventDefault();\n    const postData = {\n      title: post.title,\n      // author: user[0].pseudo,     (je suis obligé car problème avec db user)\n      author: \"Adel et oui!\",\n      content: editContent,\n      likes: post.likes,\n      id: post.id,\n    };\n    // on dispatch la fct editPost et on lui passe postData\n    dispatch(editPost(postData));\n    // aprés soumission du form; faut pas oublier de mettre setEditToggle sur false\n    setEditToggle(false);\n    // on reprend tt cette data et on va se l'exploiter dans les actions!\n  };\n  // mainteant tt est stocké dans postData (prés à être édité) par contre faut transmettre c données là!!\n  // pt ça faut tjrs appeler le HOOK dispatch; c lui qui va joindre l'action (fait plus haut avec les const)\n  // maintenant la suppression; (crud) on va dispatcher une fct qui va nous supprimer! faut juste passer l'ID du post\n  // on le fait ainsi : onClick={() => dispatch(deletePost(post.id))} ;\n  return (\n    <div className=\"post\">\n      <div className=\"edit-delete\">\n        <img\n          onClick={() => setEditToggle(!editToggle)}\n          src=\"/public/icons/edit.svg\"\n          alt=\"edit\"\n        />\n        <img\n          src=\"/public/icons/delete.svg\"\n          alt=\"delete\"\n          onClick={() => dispatch(deletePost(post.id))}\n        />\n      </div>\n      <h2>{post.title}</h2>\n      <img\n        src=\"https://picsum.photos/1500/400\"\n        className=\"post-img\"\n        alt=\"img-post\"\n      />\n      {editToggle ? (\n        <form onSubmit={(e) => handleEdit(e)}>\n          <textarea\n            default\n            value={post.content}\n            onChange={(e) => setEditContent(e.target.value)}\n          >\n            <input type=\"submit\" value=\"valider modification\"></input>\n          </textarea>\n        </form>\n      ) : (\n        <p>{post.content}</p>\n      )}\n      <div className=\"author\">\n        <h5>{post.author}</h5>\n        <Like post={post} />\n      </div>\n    </div>\n  );\n};\n\nexport default Post;\n","import React from \"react\";\nimport { useSelector } from \"react-redux\";\nimport PostForm from \"./components/PostForm\";\nimport User from \"./components/User\";\nimport Post from \"./components/Post\";\nimport { isEmpty } from \"./components/Utils\";\n\n// pas de router ici , on a une seule page, tout se passe dans les components!\n// pr commencer blog (ou API Back) en Redux (ici React-Redux) ; reprendr le même précodage des Components ici;\n\n// avant de créer le Store (trés important en Redux); il faut créer un Provider qui englobe  notre App ; il faut faire ça dans Index.js\n\nconst App = () => {\n  // comment se mapper (map) la data dans Redux: voir ce qui suit!\n  // d'abord créer une variable et stocker dedant: on appelle le HOOK useSelector (vérifier son importation)\n  // ensuite écrire ce qui suit: avec useSelector; on va se chercher les éléments (data)\n  const posts = useSelector((state) => state.postReducer);\n  console.log(posts);\n  // et on utilise la méthode \"map\" ; voir dans return (avec index fait office de key pr le map)\n  //explicationde isEmpty: \"si la const posts n'est pas vide alors tu joues le map\" attention! bien importer isEmpty!!\n  // les authentifications n'ont rien à voir avec Redux!\n\n  return (\n    <div>\n      <h1>Extreme</h1>\n      <PostForm />\n      <div className=\"content\">\n        <div className=\"post-container\">\n          {!isEmpty(posts) &&\n            posts.map((post, index) => <Post post={post} key={index} />)}\n        </div>\n        <User />\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","// on fait comme suit pr créer des reducers\r\n// faire un initial state (de base) et un export default function avec 2 papamètres\r\n// les 2 params; state et action (tous le sreducers se présentent de cette façon!!!)\r\n// c dans le return que ça se passe! (ce que fait le reducer)\r\nimport {\r\n  GET_POSTS,\r\n  ADD_POST,\r\n  EDIT_POST,\r\n  DELETE_POST,\r\n  ADD_LIKE,\r\n} from \"../actions/post.action\";\r\n\r\n// const initialState = { stateDeBase: \"hello\" };\r\n// export default function postReducer(state = initialState, action) {\r\n//   return initialState;\r\n// }      CA C'ETAIT AVANT QU'ON NE CREE LES ACTIONS\r\n\r\n// maintenant aprés création de la fct getPosts (fichier: post.action.js)\r\nconst initialState = {};\r\n// dans notre reducer ; c là qu'on va créer le Switch!!\r\n// on ajoute ici ADD_POSTS avec un nouveau case\r\n// on ajoute le nouveau post (action.payload); on l'ajoute comme ça \"\"...state\"\r\n//  si on fait [state] on aurait action.payload et un array (avec les points ... on secupèrent les données du state et on ajoute le nouveau post)\r\n// on a crée l'action, on a crée le reducer , mainteant faut lancer l'action (c dans le form: PostForm.js)\r\n// pr le EDIT, on prend le state, on fait un map de chaque posts individuellement, et on trouve le post qui correspond à notre ID\r\n// on fait post.id === action.payload.id, celui qui a le bon ID on lui change son content! avec return\r\n// on retourn tt pour pas que sa écrase, (voir le return pour case EDIT_POST)\r\n// par contre notre content sera : action.payload.content / on ajoute un else: sinon tu retournes tt les messages (si on met pas le else!, notre store sera VIDE!!!! )\r\n// pr case: DELETE_POST; on retourn le state - (moins) le post (à supprimer); on fait ça avec méthode: filter\r\nexport default function postReducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case GET_POSTS:\r\n      return action.payload;\r\n    case ADD_POST:\r\n      return [action.payload, ...state];\r\n    case EDIT_POST:\r\n      return state.map((post) => {\r\n        if (post.id === action.payload.id) {\r\n          return {\r\n            ...post,\r\n            content: action.payload.content,\r\n          };\r\n        } else return post;\r\n      });\r\n    case DELETE_POST:\r\n      return state.filter((post) => post.id !== action.payload.postId);\r\n    // on faisant comme ça on va supprimer ; on va se remapper tous les posts sauf celui qui correspond à celui qu'on a enlevé!\r\n\r\n    case ADD_LIKE:\r\n      return state.map((post) => {\r\n        if (post.id === action.payload.id) {\r\n          return {\r\n            ...post,\r\n            likes: action.payload.likes,\r\n          };\r\n        } else return post;\r\n        // c au final comme le \"put\" mais différent pour les likes (likes à la place de content)\r\n        // si on sort du if (le else) alors on return post; sinon ça le fait disparraitre du store\r\n      });\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// en faisant action.payload: il prend tt la contenance de payload (notre data avec Get) et il va la mettre dans initial state\r\n// ensuite cette data sera regroupé dans index.js (tt les reducers) qui mènent à l'index.js et qui sont dans le Store\r\n// on a crée la fonction, on a crée l'action, l'action qui va chercher la data et qui l'exploite pr incrémenter notre Store\r\n// par contre on ne l'appelle pas encore; on veut la data soit dispo dès l'ouverture de l'App; on fait ça dans index.js racine (voir fichier)\r\n","// un autre reducer\r\n// post.reducer et user.reducer comme 2 sous-parties pr stocker le reducer\r\n// c avec ces 2 qu'on va créer les mouvements dynamique en Front-end!\r\n// ici aussi on utilise le switch de la même façon! avec switch (action.type)\r\nimport { GET_USER, ADD_USER_LIKE } from \"../actions/user.action\";\r\n\r\nconst initialState = {};\r\n\r\nexport default function userReducer(state = initialState, action) {\r\n  switch (action.type) {\r\n    case GET_USER:\r\n      return action.Payload;\r\n    case ADD_USER_LIKE:\r\n      return state.map((user) => {\r\n        if (user.id === action.payload.id) {\r\n          return {\r\n            ...user,\r\n            likes: action.payload.likes,\r\n          };\r\n        } else return user;\r\n        // c au final comme le \"put\" mais différent pour les likes (likes à la place de content)\r\n        // si on sort du if (le else) alors on return user; sinon ça le fait disparraitre du store\r\n      });\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n// on return le state qui évolue en permanence, il passe de zéro (initialState = {}) à ex: action.payload ce qu'on obtient avec Get sur DB Users\r\n// le state sera égale à ce qu'il y a dans action.payload ensuite il évolura de façon dynamique\r\n// pr se le jouer dès que l'appli est lancé (même principe que avec db posts) voir : index.js\r\n","// créer dossier reducers (qui contient les reducers) et faire cet import : import { combineReducers } from \"redux\";\r\n// y mettre tous les reducers qu'on va créer ; dans le dossier reducers\r\n// postReducer pr les messages\r\n// userReducer pr les utilisateurs\r\nimport { combineReducers } from \"redux\";\r\nimport postReducer from \"./post.reducer\";\r\nimport userReducer from \"./user.reducer\";\r\n// fichier maître de reducers c index.js ( ici!! qui est fait dans dossier : reducers )\r\n// ensuite on s'appelle combineReducers au plus haut (donc dans l'index.js à la racine du dossier \"du projet\")\r\n\r\nexport default combineReducers({\r\n  postReducer,\r\n  userReducer,\r\n});\r\n","import App from \"./App\";\n// import \"./styles/index.scss\";\n\n// import React\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n// import Redux\nimport { Provider } from \"react-redux\";\nimport { applyMiddleware, createStore } from \"redux\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport thunk from \"redux-thunk\";\n// ici import de rootReducer! JS de base va lire l'index.js dans dossier reducers\nimport rootReducer from \"./reducers\";\nimport { getPosts } from \"./actions/post.action\";\nimport { getUser } from \"./actions/user.action\";\n//-------------------------------------\n\n// d'abord avant tout en Redux et dans ce fichier (ici!!) créer le PROVIDER!! qui envelopera toute l'App; à faire ICI dans index.js! comme suite:\n// comme suite: \" Provider store={store} \" englobe l'app ; comme ci-dessou!\n\n// créer variable constante store ; elle contient méthode createStore (qui est méthode de Redux) ;\n// dans createStore y a le Reducer qui les regroupe tous; il s'appelle rootReducer (pr créer fichier reducer on va faire un fichier index.js ; qu'on va créer dans dossier reducers)\n\n// se que sera rootReducer est : combineReducers (la somme de tous nos reducers) qui va constituer NOTRE STORE !!!!!\n// on fait createStore avec rootReducer ;\nconst store = createStore(\n  rootReducer,\n  //ce qui est en-bàs c pr utiliser devTools et nous aider à developper!\n  composeWithDevTools(applyMiddleware(thunk))\n);\n\n// pr data dispo dès l'ouverture de l'app faire:\n// attention! vérifier l'import de getPosts et getUser (pr data des 2 DB soient dispo dès l'ouverture)\n// ça veut dire: dès que le store est monté envoi getPosts et getUser\nstore.dispatch(getPosts());\nstore.dispatch(getUser());\n// l'étape suivante c de faire le rendu visuel et on aura fait la boucle entière d'une action dans Redux!\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}